<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>iro.js Palette Demo</title>
  <meta name="viewport" content="width=400, initial-scale=1">
  <style>
    body { font-family: sans-serif; margin: 2em; background: #f8f8f8; }
    #picker-container { margin-bottom: 1em; }
    #palette-preview { display: flex; gap: 8px; margin: 1em 0; }
    #hsv-values { font-size: 1.2em; }
  </style>
</head>
<body>
    <div id="hsv-values"></div>
    <div style="width: 880px; height: 420px; background: #303030; border-radius: 8px; border: 1px solid #ccc; margin-bottom: 1em; display: flex; flex-direction: column; align-items: center; justify-content: flex-start;">
      <div style="width: 100%; display: flex; flex-direction: row; align-items: center; justify-content: center; margin-top: 16px; margin-bottom: 8px;">
        <canvas id="interpolated-bar" width="512" height="32" style="display:block; margin:1em 0; border-radius:6px; border:1px solid #ccc;"></canvas>
        <div id="hsv-channel-select" style="display: flex; flex-direction: row; align-items: center; margin-left: 80px;">
          <button type="button" id="btn-hue" style="margin-right:8px; font-weight:bold; background:#e74c3c; color:#fff; border:none; border-radius:4px; padding:6px 18px;">H</button>
          <button type="button" id="btn-sat" style="margin-right:8px; font-weight:bold; background:#3498db; color:#fff; border:none; border-radius:4px; padding:6px 18px; opacity:0.5;">S</button>
          <button type="button" id="btn-val" style="font-weight:bold; background:#2ecc40; color:#fff; border:none; border-radius:4px; padding:6px 18px; opacity:0.5;">V</button>
        </div>
      </div>
      <div style="width: 100%; height: 320px; display: flex; align-items: center; justify-content: flex-start;">
        <canvas id="hsv-curve-canvas" width="640" height="300" style="background: #222; margin-left: 16px;"></canvas>
        <div style="display: flex; flex-direction: row; align-items: center; margin-left: 8px; height: 240px; justify-content: center;"></div>
        <div id="irojs-interface" style="margin-left: 8px; display: flex; flex-direction: column; align-items: flex-start; justify-content: center; height: 240px; width: 256px; gap: 5px;"></div>
      </div>
    </div>
    <script src="chart.umd.min.js"></script>
    <script src="chartjs-plugin-dragdata.min.js"></script>
  <script src="iro.min.js"></script>
  <script>
    // Neutral Fire preset from Jupyter notebook
    const firePreset = [
      { h: 0, s: 100, v: 30 },
      { h: 0, s: 100, v: 55 },
      { h: 0, s: 100, v: 70 },
      { h: 0, s: 100, v: 80 },
      { h: 0, s: 100, v: 75 },
      { h: 0, s: 100, v: 40 }
    ];

    window.addEventListener('DOMContentLoaded', function() {
      // Add a simple iro.js color picker interface to the right of the HSV Curve Editor
      var iroPicker = new iro.ColorPicker("#irojs-interface", {
        width: 300,
        margin: 25,
        color: { h: 0, s: 100, v: 50 },
        layoutDirection: 'horizontal',
        layout: [
          { component: iro.ui.Slider, options: { sliderType: 'hue'} },
          { component: iro.ui.Slider, options: { sliderType: 'saturation'} },
          { component: iro.ui.Slider, options: { sliderType: 'value'} }
        ]
      });

      // --- Utility functions for channel min/max and scale ---
      function getChannelMinMax(channel) {
        let arr = firePreset.map(stop => channel === 'h' ? stop.h : channel === 's' ? stop.s : stop.v);
        return {min: Math.min(...arr), max: Math.max(...arr)};
      }
      function getChannelMaxScale(channel) {
        return channel === 'h' ? 360 : 100;
      }

      // --- Dynamic min/max and base logic for iro.js hue, saturation, and value sliders ---
      let iroHueMin = 0, iroHueMax = 0, iroHueBase = [];
      let iroSatMin = 0, iroSatMax = 0, iroSatBase = [];
      let iroValMin = 0, iroValMax = 0, iroValBase = [];

      function updateIroHueSliderBounds() {
        const {min, max} = getChannelMinMax('h');
        const maxScale = getChannelMaxScale('h');
        iroHueMin = -min;
        iroHueMax = maxScale - max;
        iroHueBase = firePreset.map(stop => stop.h);
      }
      function updateIroSatSliderBounds() {
        const {min, max} = getChannelMinMax('s');
        const maxScale = getChannelMaxScale('s');
        iroSatMin = -min;
        iroSatMax = maxScale - max;
        iroSatBase = firePreset.map(stop => stop.s);
      }
      function updateIroValSliderBounds() {
        const {min, max} = getChannelMinMax('v');
        const maxScale = getChannelMaxScale('v');
        iroValMin = -min;
        iroValMax = maxScale - max;
        iroValBase = firePreset.map(stop => stop.v);
      }

      iroPicker.on('color:change', function(color) {
        // Get the new hue, saturation, and value from the iro.js sliders
        const h = Math.round(color.hsv.h);
        const s = Math.round(color.hsv.s);
        const v = Math.round(color.hsv.v);

        // Calculate average base values for all palette entries
        const avgBaseH = iroHueBase.length ? (iroHueBase.reduce((a, b) => a + b, 0) / iroHueBase.length) : 0;
        const avgBaseS = iroSatBase.length ? (iroSatBase.reduce((a, b) => a + b, 0) / iroSatBase.length) : 0;
        const avgBaseV = iroValBase.length ? (iroValBase.reduce((a, b) => a + b, 0) / iroValBase.length) : 0;

        // Calculate offsets
        let offsetH = h - avgBaseH;
        offsetH = Math.max(iroHueMin, Math.min(iroHueMax, offsetH));
        let offsetS = s - avgBaseS;
        offsetS = Math.max(iroSatMin, Math.min(iroSatMax, offsetS));
        let offsetV = v - avgBaseV;
        offsetV = Math.max(iroValMin, Math.min(iroValMax, offsetV));

        // Apply offsets to all palette entries
        const maxScaleH = getChannelMaxScale('h');
        const maxScaleS = getChannelMaxScale('s');
        const maxScaleV = getChannelMaxScale('v');
        firePreset.forEach((stop, i) => {
          let newH = iroHueBase[i] + offsetH;
          let newS = iroSatBase[i] + offsetS;
          let newV = iroValBase[i] + offsetV;
          stop.h = Math.max(0, Math.min(maxScaleH, newH));
          stop.s = Math.max(0, Math.min(maxScaleS, newS));
          stop.v = Math.max(0, Math.min(maxScaleV, newV));
          // colorPicker.colors removed; firePreset is now the source of truth
        });
        updateHSV();
      });

      // Update bounds on load and after palette changes
      updateIroHueSliderBounds();
      updateIroSatSliderBounds();
      updateIroValSliderBounds();
      iroPicker.on('colors:change', function() {
        updateIroHueSliderBounds();
        updateIroSatSliderBounds();
        updateIroValSliderBounds();
      });
                  // --- Three Channel Offset Sliders Logic ---
                  
            // --- HSV Channel Selection Logic ---
            let activeChannel = 'h';
            const channelButtons = {
              h: document.getElementById('btn-hue'),
              s: document.getElementById('btn-sat'),
              v: document.getElementById('btn-val')
            };
            function getHSVChartDatasets(active) {
              return [
                {
                  label: 'Hue',
                  data: firePreset.map(stop => stop.h),
                  borderColor: '#e74c3c',
                  backgroundColor: '#e74c3c',
                  pointRadius: 8,
                  pointHoverRadius: 12,
                  fill: false,
                  tension: 0.2,
                  yAxisID: 'y-h',
                  borderWidth: 3,
                  opacity: (active === 'h') ? 1.0 : 0.3,
                  pointBackgroundColor: (active === 'h') ? '#e74c3c' : 'rgba(231,76,60,0.3)',
                  pointBorderColor: (active === 'h') ? '#e74c3c' : 'rgba(231,76,60,0.3)',
                  borderDash: (active === 'h') ? [] : [4,4],
                  order: 1
                },
                {
                  label: 'Saturation',
                  data: firePreset.map(stop => stop.s),
                  borderColor: '#3498db',
                  backgroundColor: '#3498db',
                  pointRadius: 8,
                  pointHoverRadius: 12,
                  fill: false,
                  tension: 0.2,
                  yAxisID: 'y-sv',
                  borderWidth: 3,
                  opacity: (active === 's') ? 1.0 : 0.3,
                  pointBackgroundColor: (active === 's') ? '#3498db' : 'rgba(52,152,219,0.3)',
                  pointBorderColor: (active === 's') ? '#3498db' : 'rgba(52,152,219,0.3)',
                  borderDash: (active === 's') ? [] : [4,4],
                  order: 2
                },
                {
                  label: 'Value',
                  data: firePreset.map(stop => stop.v),
                  borderColor: '#2ecc40',
                  backgroundColor: '#2ecc40',
                  pointRadius: 8,
                  pointHoverRadius: 12,
                  fill: false,
                  tension: 0.2,
                  yAxisID: 'y-sv',
                  borderWidth: 3,
                  opacity: (active === 'v') ? 1.0 : 0.3,
                  pointBackgroundColor: (active === 'v') ? '#2ecc40' : 'rgba(46,204,64,0.3)',
                  pointBorderColor: (active === 'v') ? '#2ecc40' : 'rgba(46,204,64,0.3)',
                  borderDash: (active === 'v') ? [] : [4,4],
                  order: 3
                }
              ];
            }

            // Custom plugin to set dataset opacity
            const setOpacityPlugin = {
              id: 'setOpacity',
              beforeDatasetsDraw(chart) {
                chart.data.datasets.forEach((ds, i) => {
                  const meta = chart.getDatasetMeta(i);
                  meta.dataset.options.borderColor = ds.borderColor;
                  meta.dataset.options.backgroundColor = ds.backgroundColor;
                  meta.dataset.options.borderDash = ds.borderDash;
                  meta.data.forEach(point => {
                    point.options.backgroundColor = ds.pointBackgroundColor;
                    point.options.borderColor = ds.pointBorderColor;
                  });
                  meta.dataset.options.borderWidth = ds.borderWidth;
                  meta.dataset.options.opacity = ds.opacity;
                });
              }
            };

            const ctx = document.getElementById('hsv-curve-canvas').getContext('2d');
            let chart = new Chart(ctx, {
              type: 'line',
              data: {
                labels: firePreset.map((_, i) => i+1),
                datasets: getHSVChartDatasets('h')
              },
              options: {
                responsive: false,
                plugins: {
                  legend: { display: true, labels: { color: '#f8f8f8' } },
                  dragData: {
                    round: 1,
                    showTooltip: true,
                    // Only allow dragging the active channel
                    onDragStart: function(e, datasetIndex, index, value) {
                      // Only allow drag for active channel
                      if (['h','s','v'][datasetIndex] !== activeChannel) return false;
                      document.body.style.cursor = 'grabbing';
                    },
                    onDrag: function(e, datasetIndex, index, value) {
                      // Optionally, update UI live
                    },
                    onDragEnd: function(e, datasetIndex, index, value) {
                      document.body.style.cursor = 'default';
                      // Only update if dragging active channel
                      const ch = ['h','s','v'][datasetIndex];
                      if (ch !== activeChannel) return false;
                      if (ch === 'h') firePreset[index].h = value;
                      else if (ch === 's') firePreset[index].s = value;
                      else firePreset[index].v = value;
                      // colorPicker.colors removed; firePreset is now the source of truth
                      updateHSV();
                      setActiveChannel(activeChannel);
                      console.log('Updated firePreset and palette:', JSON.stringify(firePreset));
                    }
                  }
                },
                scales: {
                  'y-h': {
                    position: 'left',
                    min: 0,
                    max: 360,
                    title: { display: true, text: 'Hue', color: '#f8f8f8' },
                    grid: { display: false },
                    ticks: { color: '#f8f8f8' },
                    display: true
                  },
                  'y-sv': {
                    position: 'right',
                    min: 0,
                    max: 100,
                    title: { display: true, text: 'Sat/Val (%)', color: '#f8f8f8' },
                    grid: { display: false },
                    ticks: { color: '#f8f8f8' },
                    display: true
                  },
                  x: {
                    title: { display: true, text: 'Stop', color: '#f8f8f8' },
                    ticks: { color: '#f8f8f8' }
                  }
                }
              },
              plugins: [setOpacityPlugin]
            });

            function setActiveChannel(ch) {
              activeChannel = ch;
              // Update button styles
              channelButtons.h.style.opacity = (ch === 'h') ? '1.0' : '0.5';
              channelButtons.s.style.opacity = (ch === 's') ? '1.0' : '0.5';
              channelButtons.v.style.opacity = (ch === 'v') ? '1.0' : '0.5';
              // Update chart datasets in place for all channels
              const newDatasets = getHSVChartDatasets(ch);
              chart.data.datasets.forEach((ds, i) => {
                ds.data = newDatasets[i].data;
                ds.label = newDatasets[i].label;
                ds.borderColor = newDatasets[i].borderColor;
                ds.backgroundColor = newDatasets[i].backgroundColor;
                ds.pointRadius = newDatasets[i].pointRadius;
                ds.pointHoverRadius = newDatasets[i].pointHoverRadius;
                ds.fill = newDatasets[i].fill;
                ds.tension = newDatasets[i].tension;
                ds.yAxisID = newDatasets[i].yAxisID;
                ds.borderWidth = newDatasets[i].borderWidth;
                ds.opacity = newDatasets[i].opacity;
                ds.pointBackgroundColor = newDatasets[i].pointBackgroundColor;
                ds.pointBorderColor = newDatasets[i].pointBorderColor;
                ds.borderDash = newDatasets[i].borderDash;
                ds.order = newDatasets[i].order;
              });
              chart.update({animation: false});
              
            }
            channelButtons.h.addEventListener('click', () => setActiveChannel('h'));
            channelButtons.s.addEventListener('click', () => setActiveChannel('s'));
            channelButtons.v.addEventListener('click', () => setActiveChannel('v'));

      // HSV to RGB conversion (0-360, 0-100, 0-100) â†’ (0-255, 0-255, 0-255)
      function hsvToRgb(h, s, v) {
        s /= 100; v /= 100;
        let c = v * s;
        let x = c * (1 - Math.abs(((h / 60) % 2) - 1));
        let m = v - c;
        let r1, g1, b1;
        if (h < 60)      { r1 = c; g1 = x; b1 = 0; }
        else if (h < 120){ r1 = x; g1 = c; b1 = 0; }
        else if (h < 180){ r1 = 0; g1 = c; b1 = x; }
        else if (h < 240){ r1 = 0; g1 = x; b1 = c; }
        else if (h < 300){ r1 = x; g1 = 0; b1 = c; }
        else             { r1 = c; g1 = 0; b1 = x; }
        return {
          r: Math.round((r1 + m) * 255),
          g: Math.round((g1 + m) * 255),
          b: Math.round((b1 + m) * 255)
        };
      }

      function drawInterpolatedBar() {
        const canvas = document.getElementById('interpolated-bar');
        const ctx = canvas.getContext('2d');
        const stops = firePreset.map(stop => ({ h: stop.h, s: stop.s, v: stop.v }));
        const nStops = stops.length;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < canvas.width; i+=(canvas.width/256)) {
          // Find which two stops this index is between
          let t = i / (canvas.width - 1) * (nStops - 1);
          let idx = Math.floor(t);
          let frac = t - idx;
          let a = stops[idx];
          let b = stops[Math.min(idx + 1, nStops - 1)];
          // Linear interpolate HSV (hue wraps at 360)
          let dh = ((b.h - a.h + 540) % 360) - 180; // shortest direction
          let h = (a.h + frac * dh + 360) % 360;
          let s = a.s + frac * (b.s - a.s);
          let v = a.v + frac * (b.v - a.v);
          let rgb = hsvToRgb(h, s, v);
          ctx.fillStyle = `rgb(${rgb.r},${rgb.g},${rgb.b})`;
          ctx.fillRect(i, 0, canvas.width/256, canvas.height);
        }
      }

      // Update HSV values, palette preview, and interpolated bar
      function updateHSV() {
        var selectedColor = iroPicker.color;
        var hsv = selectedColor.hsv;
        var h8 = Math.round(hsv.h * 255 / 360);
        var s8 = Math.round(hsv.s * 255 / 100);
        var v8 = Math.round(hsv.v * 255 / 100);
        document.getElementById('hsv-values').innerHTML =
          `<b>Selected HSV:</b> H: ${Math.round(hsv.h)} S: ${Math.round(hsv.s)} V: ${Math.round(hsv.v)}<br>` +
          `<span style='color:#555'>8-bit: <b>H:</b> ${h8} <b>S:</b> ${s8} <b>V:</b> ${v8}</span>`;

        // palette-preview removed

        // Draw interpolated color bar
        drawInterpolatedBar();

        // --- Palette to Chart.js sync ---
        // firePreset is now the source of truth for palette stops
          // Update chart for all channels and force refresh
          if (typeof setActiveChannel === 'function' && typeof activeChannel !== 'undefined') {
            // Update chart instantly, no animation
            setActiveChannel(activeChannel);
          }
      }
      
      drawInterpolatedBar();
    });
  </script>
</body>
</html>
